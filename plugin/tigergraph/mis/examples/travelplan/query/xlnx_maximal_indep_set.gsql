/*
 * Copyright 2021 Xilinx, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

USE GRAPH @graph
SET syntax_version = "v2"
DROP QUERY assign_ids, build_csr, maximal_indep_set_alveo

# Assign nice integer IDs to vertices
CREATE QUERY assign_ids() FOR GRAPH @graph
{
    Start = {travel_plan.*};
    Start = SELECT tp FROM Start:tp
                POST-ACCUM tp.v_id = udf_get_next_vid();
}

CREATE QUERY build_csr() FOR GRAPH @graph
{
    #FILE f1("/proj/gdba/sachink/ghe/graphanalytics/plugin/tigergraph/mis/examples/travelplan/rowPtr.txt");
    #FILE f2("/proj/gdba/sachink/ghe/graphanalytics/plugin/tigergraph/mis/examples/travelplan/colIdx.txt");

    SumAccum<INT> @@global_vertex_count;
    SumAccum<INT> @edge_count;
    
    MapAccum<UINT,UINT> @@row_ptr;
    MapAccum<UINT, ListAccum<UINT> > @@col_idx;

    @@row_ptr = (0 -> 0);

    Start = {travel_plan.*};
	
	# create row pointer and column index arrays for CSR format
    TMP = SELECT tp1 FROM Start:tp1 -(tp2tp:e1)- travel_plan:tp2
                ACCUM @@col_idx += (tp1.v_id -> [tp2.v_id]),
                      tp1.@edge_count += 1
                POST-ACCUM @@row_ptr += (tp1.v_id -> tp1.@edge_count);

    #PRINT @@row_ptr as ROW_PTR
    #PRINT @@col_idx as COL_IDX

    # dump csr to files
    FOREACH i in RANGE[0, @@row_ptr.size()-1] DO
        #f1.println(@@row_ptr.get(i));
        udf_build_row_ptr(@@row_ptr.get(i));
    END;
    FOREACH i in RANGE[0, @@col_idx.size()-1] DO
        FOREACH j in RANGE[0, @@col_idx.get(i).size()-1] DO
            #f2.println(@@col_idx.get(i).get(j));
            udf_build_col_idx(@@col_idx.get(i).get(j));
        END;
    END;
}

CREATE QUERY maximal_indep_set_alveo() FOR GRAPH @graph
{
    DOUBLE vm_peak, vm_hwm;
    INT ret;
    SumAccum<INT> @@mis;

    udf_reset_timer(true);    
    # call Xilinx MIS UDF
    @@mis += udf_xilinx_mis();
    PRINT udf_elapsed_time(true) AS ExecTimeInMs;

    PRINT "Xilinx Alveo device" AS ComputationTechnique;
    ret = udf_peak_memory_usage(vm_peak, vm_hwm);
    PRINT vm_peak/1000000.0 as PeakVirtualMemoryInGB;
    PRINT vm_hwm/1000000.0 as PeakResidentMemoryInGB;
    PRINT @@mis as MisSize;
}

INSTALL QUERY assign_ids, build_csr, maximal_indep_set_alveo
