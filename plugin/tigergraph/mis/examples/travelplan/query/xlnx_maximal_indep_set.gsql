/*
 * Copyright 2021 Xilinx, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

USE GRAPH @graph
DROP QUERY assign_ids, build_csr, maximal_indep_set_alveo

# Assign nice integer IDs to vertices
CREATE QUERY assign_ids(STRING v_type, STRING e_type) FOR GRAPH @graph
{
    # Note: the query requires v_id attribute to be present on vertices

    Verts = {v_type.*};
    udf_reset_context();
    Start = SELECT v1 FROM Verts:v1 -(e_type:e)- v_type:v2
                POST-ACCUM v1.v_id = udf_get_next_vid();

    PRINT e_type as EdgeType;
    PRINT v_type as VertexType;
    PRINT udf_get_next_vid() as TotalVertices;
}

CREATE QUERY build_csr(STRING v_type, STRING e_type) FOR GRAPH @graph
{
    INT non_zero_entries = 0;
    
    MapAccum<UINT,UINT> @@row_ptr;
    MapAccum<UINT, SetAccum<UINT> > @@col_idx;

    Verts = {v_type.*};
	
	# create row pointer and column index arrays for CSR format
    Start = SELECT v1 FROM Verts:v1 -(e_type:e1)- v_type:v2
                ACCUM @@col_idx += (v1.v_id -> v2.v_id)
                POST-ACCUM @@row_ptr += (v1.v_id -> @@col_idx.get(v1.v_id).size());

    # dump csr to files
    FOREACH i in RANGE[0, @@row_ptr.size()-1] DO
        udf_build_row_ptr(@@row_ptr.get(i));
    END;
    FOREACH i in RANGE[0, @@col_idx.size()-1] DO
        FOREACH vert_id in @@col_idx.get(i) DO
            udf_build_col_idx(vert_id);
            non_zero_entries = non_zero_entries + 1;
        END;
    END;

    PRINT @@row_ptr.size() as NumberOfRows;
    PRINT non_zero_entries as NumberOfNonZeroEntries;
}

CREATE QUERY maximal_indep_set_alveo(STRING v_type, STRING e_type, BOOL print_accum = TRUE, STRING file_path = "") FOR GRAPH @graph
{
    DOUBLE vm_peak, vm_hwm;
    INT ret;
    ListAccum<INT> @@mis_v_id;
    ListAccum<vertex> @@mis;
    FILE f(file_path);
    MapAccum<UINT, vertex> @@v_id_map;

    udf_reset_timer(true);    
    # call Xilinx MIS UDF
    @@mis_v_id += udf_xilinx_mis();

    # create vertex to v_id map
    Verts = {v_type.*};
    Start = SELECT v1 FROM Verts:v1 -(e_type:e)- v_type:v2
            ACCUM @@v_id_map += (v1.v_id -> v1);

    IF file_path != "" THEN
      f.println("Vertex");
    END;

    # collect MIS vertex IDs
    FOREACH i in RANGE[0, @@mis_v_id.size()-1] DO
        @@mis += @@v_id_map.get( @@mis_v_id.get(i) );
        IF file_path != "" THEN
            f.println( @@v_id_map.get( @@mis_v_id.get(i) ) );
        END;
    END;

    PRINT udf_elapsed_time(true) AS ExecTimeInMs;

    PRINT "Xilinx Alveo device" AS ComputationTechnique;
    ret = udf_peak_memory_usage(vm_peak, vm_hwm);
    PRINT vm_peak/1000000.0 as PeakVirtualMemoryInGB;
    PRINT vm_hwm/1000000.0 as PeakResidentMemoryInGB;
    PRINT @@mis.size() as MisSize;

    IF print_accum THEN
      PRINT @@mis;
    END;
}

INSTALL QUERY assign_ids, build_csr, maximal_indep_set_alveo
