DROP QUERY louvain_distributed_cpu
CREATE DISTRIBUTED QUERY louvain_distributed_cpu(
    INT max_iter, set<STRING> vertex_types, set<STRING> edge_types, FILE community_result) 
{ 
	TYPEDEF TUPLE <FLOAT deltaQ, FLOAT OutDgr, VERTEX cc> move; 
	SumAccum<FLOAT> @community_sum_degrees; #sum of the degrees of all the vertices in community C of the vertex
    SumAccum<FLOAT> @@Q;
	ListAccum<VERTEX> @community_center; #the community center
	SumAccum<FLOAT> @cc_OD;
	MapAccum<VERTEX,SumAccum<FLOAT>> @A; #A[c]: sum of the edge weights for the edges in community c
	MaxAccum<move> @best_move; # highest dQ, highest -Outdegree, highest community_center
	ListAccum<VERTEX> @community_member_list;  #community member list
	SumAccum<FLOAT> @@m; # total edge weight
	ListAccum<INT> @ccIntermediate;
	OrAccum<BOOL> @@ccChange;

    Start = {vertex_types}; 
	
	// initialize @community_center
	log(True, "XXYYZZ @community_center initialization started");
	Start = SELECT s FROM Start:s-((edge_types):e)->:t 
		ACCUM 
			@@m += 1
		POST-ACCUM 
			s.@community_center += s,
			s.@cc_OD = s.outdegree()
	;

    //print @@m;

	log(True, "XXYYZZ startsize=", Start.size());

	// update @community_center in the first iteration
	Start = SELECT t FROM Start:s-((edge_types):e)->:t
		ACCUM
			t.@best_move += move(1 + 1/2/@@m*t.outdegree() * (t.outdegree() - s.outdegree()), -s.@cc_OD, s.@community_center.get(0))
		POST-ACCUM
			IF getDeltaQ(t.@best_move) > 0 THEN
				IF -getOutDegree(t.@best_move) < t.@cc_OD THEN  //
					t.@community_center.clear(), 
					t.@community_center += getCc(t.@best_move),
					t.@cc_OD = -getOutDegree(t.@best_move),
                    @@Q += getDeltaQ(t.@best_move)/(2*@@m),
					@@ccChange += TRUE
				ELSE 
					IF -getOutDegree(t.@best_move) == t.@cc_OD AND getvid(t) < getvid(getCc(t.@best_move))  THEN
						t.@community_center.clear(),
						t.@community_center += getCc(t.@best_move),
						t.@cc_OD = -getOutDegree(t.@best_move),
                        @@Q += getDeltaQ(t.@best_move)/(2*@@m),
						@@ccChange += TRUE
					END
				END
			END,
			t.@ccIntermediate += getvid(t.@community_center.get(0))

	;
  
    //PRINT @@Q AS modularity;

	log(True, "XXYYZZ @community_center initialization ended");


	WHILE @@ccChange LIMIT max_iter DO
		@@ccChange = FALSE;
        print @@ccChange;
		// initialize @community_member_list
		log(True, "XXYYZZ ith iteration started");
		Start = SELECT s FROM Start:s 
			POST-ACCUM 
				s.@community_sum_degrees = 0,
				s.@community_member_list.clear(),
				s.@A.clear()
		;

		log(True, "XXYYZZ compute  v.@community_member_list += s");
    	log(True, "XXYYZZ startsize=", Start.size());

		Start = SELECT s FROM Start:s 
			ACCUM FOREACH v IN s.@community_center DO
				CASE WHEN getvid(v) != -1 THEN v.@community_member_list += s END
			END
		;

		log(True, "XXYYZZ compute @A");
		Start = SELECT s FROM Start:s-((edge_types):e)->:t 
			ACCUM s.@A += (t.@community_center.get(0)->1)
		;
    	log(True, "XXYYZZ compute @A startsize=", Start.size());

		log(True, "XXYYZZ compute @community_sum_degrees");
		Start = SELECT s FROM Start:s 
			ACCUM FOREACH v IN s.@community_center DO
				CASE WHEN getvid(v) != -1 THEN v.@community_sum_degrees += s.outdegree() END
			END
		;

		Start = SELECT s FROM Start:s 
			ACCUM FOREACH v IN s.@community_member_list DO
				CASE WHEN getvid(v) != -1 THEN v.@community_sum_degrees = s.@community_sum_degrees END
			END
		;

		log(True, "XXYYZZ compute @max_dQ");
		// compute @max_dQ
		Start = SELECT s FROM Start:s-((edge_types):e)->:t
			ACCUM
				INT A_s = 0,
				IF s.@A.containsKey(s) THEN
					A_s = s.@A.get(s)
				END,
				s.@best_move += move(s.@A.get(t.@community_center.get(0))-A_s+1/2/@@m*s.outdegree()*(s.@community_sum_degrees-t.@community_sum_degrees), 
                                     -t.@cc_OD, t.@community_center.get(0))
			POST-ACCUM
				IF getDeltaQ(s.@best_move) > 0 THEN
					IF -getOutDegree(s.@best_move) < s.@cc_OD THEN
						s.@community_center.clear(),
						s.@community_center += getCc(s.@best_move),
						s.@cc_OD = -getOutDegree(s.@best_move),
                        @@Q += getDeltaQ(s.@best_move)/(2*@@m),
						@@ccChange += TRUE
					ELSE 
						IF -getOutDegree(s.@best_move) == s.@cc_OD AND getvid(s.@community_center.get(0)) < getvid(getCc(s.@best_move))  THEN
							s.@community_center.clear(),
							s.@community_center += getCc(s.@best_move),
							s.@cc_OD = -getOutDegree(s.@best_move),
                            @@Q += getDeltaQ(s.@best_move)/(2*@@m),
							@@ccChange += TRUE
						END
					END
				END,
			s.@ccIntermediate += getvid(s.@community_center.get(0))
		;
        //PRINT @@Q AS modularity;
		log(True, "XXYYZZ ith iteration ended");
	END;

    PRINT @@Q AS finalModularity;

    log(True, "XXYYZZ final startsize=", Start.size());
	Start = SELECT s FROM Start:s
		POST-ACCUM
			#community_result.println("s", s, "community_center.get", getvid(s.@community_center.get(0)), "ccIntermediate:", s.@ccIntermediate)
   			#community_result.println("s", s, "community_center.get", s.@community_center.get(0), "ccIntermediate:", s.@ccIntermediate)
   			community_result.println(s, s.@community_center)
	;


	
}
INSTALL QUERY louvain_distributed_cpu
